# kthCharacter Function - Detailed Mathematical Explanation

This document explains the math and logic behind the efficient solution for finding the `k`-th character in a string `word`, generated by a repeated transformation process.

---

## Problem Description

We begin with a string:

```
word = "a"
```

Each operation consists of two steps:

1. Generate a transformed copy of `word` by shifting each character to its **next** character in the English alphabet (wrapping around: `'z'` becomes `'a'`).
2. Append this transformed copy to the end of the original `word`.

### Example Transformations

| Step | word          | Length |
| ---- | ------------- | ------ |
| 0    | a             | 1      |
| 1    | a + b         | 2      |
| 2    | ab + bc       | 4      |
| 3    | abbc + ccd    | 8      |
| 4    | abbc... + ... | 16     |

We observe that the length of `word` **doubles** after each operation.

---

## Mathematical Insight

Let us define:

* `S_n` as the string after `n` transformations.
* `L_n = 2^n` as the length of `S_n`.

For example:

* `S_0 = "a"` with length `1`
* `S_1 = "ab"` with length `2`
* `S_2 = "abbc"` with length `4`
* `S_3 = "abbcbccd"` with length `8`

So, to find the `k`-th character, we can compute the smallest `L` such that `L >= k`. This will tell us how many transformations were needed for the string to be long enough.

---

## Reverse Analysis Strategy

We do **not** construct the full string because it grows exponentially. Instead, we simulate the transformations **in reverse** to deduce what the original character was.

Let’s denote:

* `l`: the length of the current version of `word`, initialized as the smallest power of 2 such that `l >= k`
* `c`: the current character we're tracing, initially `'a'`

### At each reverse step:

1. Divide `l` by 2: this gives us the midpoint of the word at that transformation step.
2. If `k` is greater than `l / 2`, it lies in the transformed (second) half:

   * Subtract `l / 2` from `k` to adjust its position.
   * Increment character `c` to its next in the alphabet.
3. If `k <= l / 2`, the character lies in the original half: do nothing to `k`, and keep `c` unchanged.

Repeat until `l == 1`. At this point, `c` holds the original character that would be in position `k`.

---

## Code Walkthrough

```cpp
char kthCharacter(int k) {
    int l = 1;
    while (l < k) l *= 2;

    char c = 'a';

    while (l > 1) {
        l /= 2;
        if (k > l) {
            k -= l;
            c = (c - 'a' + 1) % 26 + 'a';
        }
    }

    return c;
}
```

### Example

Input: `k = 5`

* Initial `l = 8` (smallest power of 2 ≥ 5)
* Step 1: `k = 5 > 4` → `k = 1`, `c = 'b'`
* Step 2: `k = 1 <= 2` → no change
* Step 3: `k = 1 <= 1` → end

Output: `'b'`

---

## Time and Space Complexity

* **Time Complexity**: `O(log k)` — since we only reduce `l` by half each time
* **Space Complexity**: `O(1)` — we use only constant space

---

## Conclusion

This solution relies on mathematical properties of the word growth pattern. By observing that the length doubles and using reverse analysis, we can deduce the character at any position `k` without constructing the full string.
